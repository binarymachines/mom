# example of multi-engine services

def main(args):
    # subprocess.Popen([util.get_kivy_directory(), 'cachemon.py', '--size=1200x100'], shell=True)

    os.chdir(util.get_working_directory())
    service = launch(args)


    service = launch(args, run=False)
    if service is not None:
        try:
            create_func = get_process_create_func()

            path_args = start.get_paths(args)
            paths = shallow.get_directories() if path_args is None else path_args

            context = DirectoryContext('path context', paths)
            if args['--expand-all']:
                context.set_param('all', 'expand_all', True)

            directive = direct.create(paths)

            a = create_func('a service', context)
            a.after = after
            a.before = before
            # b = create_func('b service', context)
            # c = create_func('c service', context)

            service.queue(a)

            # TODO: a call to service.handle_services() should NOT be required here or anywhere else outside of the service process
            service.handle_services()

            # TODO: tests with threaded services reveals design/implementation flaws
            # service.run(create_func('Threaded worker', context), True, before, after)
            # service.run(create_func('Threaded sleeper', context), True)
        except Exception, err:
            print 'Unable to create process due to %s' % err.message

if __name__ == '__main__':
    args = docopt(__doc__)
    main(args)
